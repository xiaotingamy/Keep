# 算法练习

## 2020.01.04～2020.01.10

### 1.两数之和

#### 题目

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

你可以按任意顺序返回答案。

#### 解答

方法一： 暴力枚举法

枚举数组中的每一个数 x，寻找数组中是否存在 target - x。
遍历数组，寻找等于target-x的值。遍历时注意每个位于x之前的元素都已经匹配相加过了，因此，只需要在x数值后面寻找等于target-x的数值就行了。

```javascript
var twoSum = function(nums, target) {
    let len = nums.length
    for (let i = 0; i < len; i++) {
        for (let j = i + 1; j < len; j++) {
            if (nums[i] + nums[j] === target) {
                return [i, j]
            }
        }
    }
    return []
}
```

方法二： ES6的MAP(哈希表法)

使用键值对数据结构。

使用map结构的set方法，将x数值作为键(key)，其索引作为值(value)。

通过has方法寻找target-x

通过get方法获取到target-x的索引值(value)

```javascript
var twoSum = function (nums, target) {
    let map = new Map()
    for (let i = 0; i < nums.length; i++) {
        if (map.has(target - nums[i])) {
            return [map.get(target - nums[i]), i]
        }
        map.set(nums[i], i)
    }
    return []
}
```

### 2. 整数反转

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [Math.pow(−2, 31),  Math.pow(2, 31) − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

## 反转整数数字的方法：弹出和推入数字

假设整数是x；rev存储反转后的整数的变量，初始值为0； let rev = 0;

1、第一步，弹出最末位数字。和10取余，得到最末位的数字；即 123 得到最末位数字 3 ， -123 得到最末位数字 -3；

```javascript
pop = x % 10;
```

2、第二步，整数x，要舍去最后一位数字。即 123 要变成 12 ， -123 要变成 -12

```javascript
x >= 0 ? x = Math.floor(x / 10) : x = Math.ceil(x / 10);
```

3、第三步，推入最末位数字。

```javascript
rev = rev * 10 + pop;
```

## 溢出前进行检查

整数反转过程中，在第三步，推入最末位数字时可能会溢出，所以需要做逻辑判断。

最大值 INT_MAX 2^31 - 1 = 2147483647

最小值 INT_MIN -2^31 = -2147483648

对于强类型语言来说，可以这样判断：

如果 *rev > INT_MAX / 10*， 或者 *rev  == INT_MAX / 10 && pop > 7*，那么返回0；

如果 *rev < INT_MIN / 10*， 或者 *rev == INT_MIN / 10 && pop < -8*，那么返回0；

对于js来说，可以直接计算：

*rev > (INT_MAX - pop) / 10* 时, 返回0

*rev < (INT_MIN - pop) / 10* 时, 返回0

```javascript
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
    let rev = 0;
    const INT_MAX = 2147483647;
    const INT_MIN = -2147483648;
    while (x != 0) {
        let pop = x % 10;
        x >= 0 ? x = Math.floor(x / 10) : x = Math.ceil(x / 10);
        if (rev > (INT_MAX - pop) / 10) return 0
        if (rev < (INT_MIN - pop) / 10) return 0
        rev = rev * 10 + pop;
    }
    return rev
};
```

### 3. 回文数

题目：

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

示例 1:

输入: 121

输出: true

示例 2:

输入: -121

输出: false

解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

示例 3:

输入: 10

输出: false

解释: 从右向左读, 为 01 。因此它不是一个回文数。

解答：

在做完第2题【整数反转】后，再看这题【回文数】，很容易想到一个解题思路：将整数反转后的数字和原始值进行比较，如果相等，说明是个回文数。 但是会遇到一个问题，反转后的整数溢出的问题。

所以考虑到回文数的特性，我们可以只反转数字的一半，可以避免整个数字反转可能导致的溢出问题。因为是回文数，所以它的后半部分反转后应该与原始数字的前半部分相同。

举个例子，数字“1221”， 后半部分反转后数字是“12”和前部分相同。

那么，现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？

由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。

```javascript
var isPalindrome = function(x) {
    // 如果是负数，则肯定不是回文数
    // 如果不是0且个位数为0，则肯定不是回文数
    if (x < 0 || (x % 10 == 0 && x != 0)) {
        return false;
    }
    let rev = 0
    while (x > rev) {
        let pop = x % 10;
        rev = rev * 10 + pop;
        x >= 0 ? x = Math.floor(x / 10) : x = Math.ceil(x / 10);
    }
    return x === rev || x === Math.floor(rev / 10)
};
```
